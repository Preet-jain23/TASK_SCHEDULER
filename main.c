/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include<stdio.h>

void init_systick_timer(uint32_t Tick_hz);
#define System_clk 16000000U

#define SIZE_TASK_STACK  1024U
#define SIZE_SCHED_STACK 1024U

#define SRAM_START 0x20000000
#define SIZE_SRAM  ((128)*(1024))
#define SRAM_END   ((SRAM_START)+1024*128)
#define max_task 5

#define T1_STACK_START SRAM_END
#define T2_STACK_START ((SRAM_END)-(1*SIZE_TASK_STACK))
#define T3_STACK_START ((SRAM_END)-(2*SIZE_TASK_STACK))
#define T4_STACK_START ((SRAM_END)-(3*SIZE_TASK_STACK))
#define IDLE_STACK_START ((SRAM_END)-(4*SIZE_TASK_STACK))
#define SCHED_STACK_START ((SRAM_END)-(5*SIZE_TASK_STACK))

#define INTERRUPT_DISABLE()  do{__asm volatile ("MOV R0,#0x1"); asm volatile("MSR PRIMASK,R0"); } while(0)

#define INTERRUPT_ENABLE()  do{__asm volatile ("MOV R0,#0x0"); asm volatile("MSR PRIMASK,R0"); } while(0)

uint32_t g_tick_count=0;

#define TICK_HZ 1000U

#define XPSR_DUMMY 0x01000000U
uint32_t current_task=1;
uint32_t *ICSR=(uint32_t*)0xE000ED04;


void idle_task(void);
void task1_handler(void);
void task2_handler(void);
void task3_handler(void);
void task4_handler(void);
void init_task_stack(void);


__attribute__((naked)) void init_scheduler_stack(uint32_t sched_top_of_stack);




//led.h


#define LED_GREEN  12
#define LED_ORANGE 13
#define LED_RED    14
#define LED_BLUE   15

#define DELAY_COUNT_1MS 		 1250U
#define DELAY_COUNT_1S  		(1000U * DELAY_COUNT_1MS)
#define DELAY_COUNT_500MS  		(500U  * DELAY_COUNT_1MS)
#define DELAY_COUNT_250MS 		(250U  * DELAY_COUNT_1MS)
#define DELAY_COUNT_125MS 		(125U  * DELAY_COUNT_1MS)

#define READY_STATE  0x00
#define BLOCKED_STATE 0xff

void led_init_all(void);
void led_on(uint8_t led_no);
void led_off(uint8_t led_no);
void delay(uint32_t count);


typedef struct{

	uint32_t psp_value;
	uint32_t current_state;
	uint32_t block_count;
	void(*task_handler)(void);
}TCB;

TCB user_task[max_task];





int main(void){
	enable_fault();
	init_scheduler_stack(SCHED_STACK_START);
    init_task_stack();

	led_init_all();

	init_systick_timer(TICK_HZ);

     change_sp_to_psp();

     task1_handler();

     for(;;);
}

void task_delay(uint32_t tick_count){

	INTERRUPT_DISABLE();

	if(current_task != 0){
	user_task[current_task].block_count=tick_count+g_tick_count;
	user_task[current_task].current_state=BLOCKED_STATE;

	 *ICSR |= (1<<28);
	}
	INTERRUPT_ENABLE();
}



void task1_handler(void){
	while(1){
		led_on(LED_BLUE);
		task_delay(10000);
		led_off(LED_BLUE);
		task_delay(10000);
	}
}

void task2_handler(void){
	while(1){
		        led_on(LED_GREEN);
		        task_delay(40000);
				led_off(LED_GREEN);
				 task_delay(40000);
	}
}

void task3_handler(void){
	while(1){
		        led_on(LED_ORANGE);
		        task_delay(30000);
				led_off(LED_ORANGE);
				 task_delay(30000);
	}
}

void task4_handler(void){
	while(1){
		         led_on(LED_RED);
		         task_delay(20000);
				led_off(LED_RED);
				 task_delay(20000);
	}
}

void init_systick_timer(uint32_t Tick_hz){
	int count_value=System_clk/Tick_hz;
	 uint32_t *systick_ctrl=(uint32_t*)0xE000E010;
	 uint32_t *reload=(uint32_t*)0xE000E014;

	 *reload&=~(0x00FFFFFF);
	 *reload|=count_value;

	 *systick_ctrl |=(1<<2);
	 *systick_ctrl |=(1<<1);

	 *systick_ctrl |=(1<<0);//enable
}



void init_task_stack(void){

	user_task[0].current_state=READY_STATE;
	user_task[1].current_state=READY_STATE;
	user_task[2].current_state=READY_STATE;
	user_task[3].current_state=READY_STATE;
	user_task[4].current_state=READY_STATE;



	user_task[0].psp_value=IDLE_STACK_START;
	user_task[1].psp_value=T1_STACK_START;
	user_task[2].psp_value=T2_STACK_START;
	user_task[3].psp_value=T3_STACK_START;
	user_task[4].psp_value=T4_STACK_START;


	user_task[0].task_handler=idle_task;
	user_task[1].task_handler=task1_handler;
	user_task[2].task_handler=task2_handler;
	user_task[3].task_handler=task3_handler;
	user_task[4].task_handler=task4_handler;




	uint32_t *pPSP;
	for(uint8_t i=0 ;i<max_task;i++){
		 pPSP=(uint32_t*)user_task[i].psp_value;

		 *pPSP--;

		 *pPSP=XPSR_DUMMY;

		 *pPSP--;

		  *pPSP=user_task[i].task_handler;

		  *pPSP--;

		  *pPSP=0xFFFFFFFD;

		  for(uint32_t j=0;j<13;j++){
			  *pPSP--;

			  *pPSP=0;
		  }

		  user_task[i].psp_value=(uint32_t)pPSP;
	}

}

void idle_task(void){
	while(1);
}

void enable_fault(void){
	uint32_t *pSHC=(uint32_t*)0xE000ED24;
	*pSHC|=1<<16;
	*pSHC|=1<<18;
	*pSHC|=1<<17;


}

void  MemManage_Handler(void){
	printf("MemManagefault");
	while(1);
}
void BusFault_Handler(void){
	printf("Busfault");
	while(1);
}
void UsageFault_Handler(void){
	printf("usagefault");
	while(1);
}
uint32_t get_psp_value(void){
	return user_task[current_task].psp_value;
}


__attribute__((naked)) void change_sp_to_psp(void){


	__asm volatile("PUSH {LR}");
	__asm volatile("BL get_psp_value");
	__asm volatile("MSR PSP,R0");
	__asm volatile("POP {LR}");

	__asm volatile("MOV R0,#0x02");
	__asm volatile("MSR CONTROL,R0");
	__asm volatile("BX LR");
}


__attribute__((naked)) void init_scheduler_stack(uint32_t sched_top_of_stack){
	__asm volatile("MSR MSP,R0");
	__asm volatile("BX LR");
}

void update_next_task(void){
	uint32_t state=BLOCKED_STATE;

	for(uint32_t i=1;i<max_task;i++){
		current_task++;
		current_task=current_task%max_task;
		if(user_task[current_task].current_state == READY_STATE  && current_task!=0){
			state=user_task[current_task].current_state;
			break;
		}
	}
		if(state==BLOCKED_STATE){
		   current_task=0;

		}
		return;

}
void save_psp_value(uint32_t stack_addr){
	user_task[current_task].psp_value=stack_addr;
}

void update_count(void){
	g_tick_count=g_tick_count+1;
}

void update_block_count(void){
	for(uint32_t i=1;i<max_task;i++){
		if(user_task[i].current_state  == BLOCKED_STATE){
			if(user_task[i].block_count == g_tick_count){
				user_task[i].current_state = READY_STATE;
			}
		}
	}
}

__attribute__((naked)) void PendSV_Handler(void){
	__asm volatile("MRS R0,PSP");
	__asm volatile("STMDB R0!,{R4-R11}");
	__asm volatile("PUSH {LR}");
    __asm volatile("BL save_psp_value");

	__asm volatile("BL update_next_task");
    __asm volatile("BL get_psp_value");


     __asm volatile("LDMIA R0!,{R4-R11}");
     __asm volatile("MSR PSP,R0");
     __asm volatile("POP {LR}");
    __asm volatile("BX LR");
}
 void SysTick_Handler(void){
	//get curretn running task psp value
  update_count();

  update_block_count();

   *ICSR |= (1<<28);
}



//led.c




void delay(uint32_t count)
{
  for(uint32_t i = 0 ; i < count ; i++);
}

void led_init_all(void)
{

	uint32_t *pRccAhb1enr = (uint32_t*)0x40023830;
	uint32_t *pGpiodModeReg = (uint32_t*)0x40020C00;


	*pRccAhb1enr |= ( 1 << 3);
	//configure LED_GREEN
	*pGpiodModeReg |= ( 1 << (2 * LED_GREEN));
	*pGpiodModeReg |= ( 1 << (2 * LED_ORANGE));
	*pGpiodModeReg |= ( 1 << (2 * LED_RED));
	*pGpiodModeReg |= ( 1 << (2 * LED_BLUE));

#if 0
	//configure the outputtype
	*pGpioOpTypeReg |= ( 1 << (2 * LED_GREEN));
	*pGpioOpTypeReg |= ( 1 << (2 * LED_ORANGE));
	*pGpioOpTypeReg |= ( 1 << (2 * LED_RED));
	*pGpioOpTypeReg |= ( 1 << (2 * LED_BLUE));
#endif

    led_off(LED_GREEN);
    led_off(LED_ORANGE);
    led_off(LED_RED);
    led_off(LED_BLUE);



}

void led_on(uint8_t led_no)
{
  uint32_t *pGpiodDataReg = (uint32_t*)0x40020C14;
  *pGpiodDataReg |= ( 1 << led_no);

}

void led_off(uint8_t led_no)
{
	  uint32_t *pGpiodDataReg = (uint32_t*)0x40020C14;
	  *pGpiodDataReg &= ~( 1 << led_no);

}
